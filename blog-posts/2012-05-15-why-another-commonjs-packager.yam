[post title="Why another CommonJs packager" tags="webpack webapp caching optimizing"]

## What can be done for good "performance" of static resources in a web app?

### I. Cache the resources

To best leverage caching your resources should be cached forever. This results in the problem, that you cannot exchange the resources anymore. So you (or the compiler) name the resources so their name contains a hash of its content. This introduces a bit more complexity: You (or the compiler) have to update all references of the resource if you want to change it.

### II. Transfer only few files

[more]

Because the browser limits the connection count to one server and each file has a http overhead, transferring many files (from a single server) is bad. Therefore web sites concat files. This process is really easy for files of the same type (css+css, js+js, not so easy but possible for img+img). Approaches for different file types are available but are more complex (img+css DataUrl, css+js small script).

### III. Transfer only required files

Most web apps consist of multiple pages which are never always visible at the same time. Some parts of the resources may not be required for the current page. Downloading only the required parts makes the first page visible faster and is more attractive to the user. *Who likes a web app that takes a long time to load?* Pages that are likely to be used next, can be prefetched by the developer.

### IV. Compile before serving

If you use a template language (i.e. `jade`) to generate parts of your page, you should compile them before serving them to the client. Three reasons for this: Compiling is a expensive process. It could take some time on weak clients. The compiler may have a bigger size, than the "runtime" needed for executing the compiled templates. It also easier to minimize compiled templates if they are in javascript code. The same is true for alternative languages like `coffeescript` or `less`.

### V. Minimize files

This saves size. There are good minimizers available for many common file types (css, js).

## Why another CommonJs packager?

Existing CommonJs packager did only a part of the points above. The developer has to take care of the other points.

So I developed [webpack](https://github.com/sokra/modules-webpack) which will take care of all the points above.

## How webpack support the points

Getting **point I** is really easy: The `webpack` simply adds a hash to all output files and automatically takes care for the references.

Getting **point II** is more complex. Like any other packager it can bundle all javascript sources into a single file. This may not be enough. There are still stylesheets and images remaining. Stylesheets can be merged into the javascript as a string and applied to the document with a few lines of code. Images can be stored as DataUrl in the stylesheet or the javascript code, but this does not work for all browsers (so it is disabled by default).

Regarding **point III** there is a conflict with point II. If all the stuff is in a single file, there is a lot of unused stuff transferred to the client. On big web app this would result in a long initial loading time. `webpack` solves this by providing a feature named "Code Splitting" (inspired by [GWT](http://code.google.com/p/google-web-toolkit/wiki/CodeSplitting)) which splits your single file by a developer defined split points into multiple files (chunks). If the developer applies a good splitting, the web app will only have to download the required stuff and have a shorter loading time. Each chunk can be cached separately.

**Point IV** brings `webpack` to the point that it will allow "loader" or "preprocessors" to preprocess a file. A "loader" takes some input (in example a `jade`-template), does something with it and then emits javascript code. Multiple loaders can be piped to support complex operations. A developer can write their own loaders to generate javascript code while compiling.

**Point V**. Easy.

## Additional features

* debugging support with `// @sourceURL=`
* detailed info about code splitting
* raw, json, jade, coffee, css, less loaders out of the box and bound to file extensions
* bundle loader, which creates a chunk from the file
* file loader, which emits a separate file to the output and returns the url
* expression in require calls are supported to include a directory of files ( `require("./templates/"+name+".jade")` )
* shell and programmatically usage
* grunt task available
* watch mode
* many config options
* polyfill for node.js to use the techniques (loaders, ...) in native code

## Tell me more

[read documentation on github](https://github.com/sokra/modules-webpack)
